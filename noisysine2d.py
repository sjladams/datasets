import torch
import math

from .utils import xdata, noise, points_to_paths


def noisysine2d(x):
    sigma = 0.2
    y_dim1 = (0.5 * torch.sin(2 * math.pi * x[..., 0]))[..., None]
    y_dim2 = (0.5 * torch.sin(2 * math.pi * x[..., 1]))[..., None]
    return y_dim1 + y_dim2 + noise(y_dim1.shape, sigma=sigma)


def xdata2d(dataset_size: int, generate_paths: bool, **kwargs):
    """
    paths are following a wiener process over input space starting at each grid point
    :param dataset_size:
    :param generate_paths:
    :param kwargs:
    :return:
    """
    x_dim1 = xdata(dataset_size=int(math.sqrt(dataset_size)), generate_paths=False, **kwargs).squeeze()
    x_dim2 = xdata(dataset_size=int(math.sqrt(dataset_size)), generate_paths=False, **kwargs).squeeze()
    x = torch.cartesian_prod(x_dim2, x_dim1)
    if generate_paths:
        return points_to_paths(x=x, wiener_window=True, **kwargs)
    else:
        return x


def load_noisysine2d(train_dataset_size: int = 2**11, test_dataset_size: int = 2**11, **kwargs):
    """
    Generates data from a two-dimensional sine with additive gaussian noise. If required, paths are generated by
    wiener processes over the input space

    :param train_dataset_size:
    :param test_dataset_size:
    :param kwargs:
    :return:
    """
    x_train = xdata2d(dataset_size=train_dataset_size, generate_random=True, **kwargs)
    y_train = noisysine2d(x_train)
    x_test = xdata2d(dataset_size=test_dataset_size, generate_random=True, **kwargs)
    y_test = noisysine2d(x_test)

    input_size, output_size = x_train.shape[-1], y_train.shape[-1]
    return x_train, y_train, x_test, y_test, input_size, output_size
